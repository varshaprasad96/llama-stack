/*
Llama Stack Specification

This is the specification of the Llama Stack that provides                 a set of endpoints and their corresponding interfaces that are tailored to                 best leverage Llama Models.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// TurnStepsInner - struct for TurnStepsInner
type TurnStepsInner struct {
	InferenceStep *InferenceStep
	MemoryRetrievalStep *MemoryRetrievalStep
	ShieldCallStep *ShieldCallStep
	ToolExecutionStep *ToolExecutionStep
}

// InferenceStepAsTurnStepsInner is a convenience function that returns InferenceStep wrapped in TurnStepsInner
func InferenceStepAsTurnStepsInner(v *InferenceStep) TurnStepsInner {
	return TurnStepsInner{
		InferenceStep: v,
	}
}

// MemoryRetrievalStepAsTurnStepsInner is a convenience function that returns MemoryRetrievalStep wrapped in TurnStepsInner
func MemoryRetrievalStepAsTurnStepsInner(v *MemoryRetrievalStep) TurnStepsInner {
	return TurnStepsInner{
		MemoryRetrievalStep: v,
	}
}

// ShieldCallStepAsTurnStepsInner is a convenience function that returns ShieldCallStep wrapped in TurnStepsInner
func ShieldCallStepAsTurnStepsInner(v *ShieldCallStep) TurnStepsInner {
	return TurnStepsInner{
		ShieldCallStep: v,
	}
}

// ToolExecutionStepAsTurnStepsInner is a convenience function that returns ToolExecutionStep wrapped in TurnStepsInner
func ToolExecutionStepAsTurnStepsInner(v *ToolExecutionStep) TurnStepsInner {
	return TurnStepsInner{
		ToolExecutionStep: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *TurnStepsInner) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into InferenceStep
	err = newStrictDecoder(data).Decode(&dst.InferenceStep)
	if err == nil {
		jsonInferenceStep, _ := json.Marshal(dst.InferenceStep)
		if string(jsonInferenceStep) == "{}" { // empty struct
			dst.InferenceStep = nil
		} else {
			if err = validator.Validate(dst.InferenceStep); err != nil {
				dst.InferenceStep = nil
			} else {
				match++
			}
		}
	} else {
		dst.InferenceStep = nil
	}

	// try to unmarshal data into MemoryRetrievalStep
	err = newStrictDecoder(data).Decode(&dst.MemoryRetrievalStep)
	if err == nil {
		jsonMemoryRetrievalStep, _ := json.Marshal(dst.MemoryRetrievalStep)
		if string(jsonMemoryRetrievalStep) == "{}" { // empty struct
			dst.MemoryRetrievalStep = nil
		} else {
			if err = validator.Validate(dst.MemoryRetrievalStep); err != nil {
				dst.MemoryRetrievalStep = nil
			} else {
				match++
			}
		}
	} else {
		dst.MemoryRetrievalStep = nil
	}

	// try to unmarshal data into ShieldCallStep
	err = newStrictDecoder(data).Decode(&dst.ShieldCallStep)
	if err == nil {
		jsonShieldCallStep, _ := json.Marshal(dst.ShieldCallStep)
		if string(jsonShieldCallStep) == "{}" { // empty struct
			dst.ShieldCallStep = nil
		} else {
			if err = validator.Validate(dst.ShieldCallStep); err != nil {
				dst.ShieldCallStep = nil
			} else {
				match++
			}
		}
	} else {
		dst.ShieldCallStep = nil
	}

	// try to unmarshal data into ToolExecutionStep
	err = newStrictDecoder(data).Decode(&dst.ToolExecutionStep)
	if err == nil {
		jsonToolExecutionStep, _ := json.Marshal(dst.ToolExecutionStep)
		if string(jsonToolExecutionStep) == "{}" { // empty struct
			dst.ToolExecutionStep = nil
		} else {
			if err = validator.Validate(dst.ToolExecutionStep); err != nil {
				dst.ToolExecutionStep = nil
			} else {
				match++
			}
		}
	} else {
		dst.ToolExecutionStep = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.InferenceStep = nil
		dst.MemoryRetrievalStep = nil
		dst.ShieldCallStep = nil
		dst.ToolExecutionStep = nil

		return fmt.Errorf("data matches more than one schema in oneOf(TurnStepsInner)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(TurnStepsInner)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src TurnStepsInner) MarshalJSON() ([]byte, error) {
	if src.InferenceStep != nil {
		return json.Marshal(&src.InferenceStep)
	}

	if src.MemoryRetrievalStep != nil {
		return json.Marshal(&src.MemoryRetrievalStep)
	}

	if src.ShieldCallStep != nil {
		return json.Marshal(&src.ShieldCallStep)
	}

	if src.ToolExecutionStep != nil {
		return json.Marshal(&src.ToolExecutionStep)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *TurnStepsInner) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.InferenceStep != nil {
		return obj.InferenceStep
	}

	if obj.MemoryRetrievalStep != nil {
		return obj.MemoryRetrievalStep
	}

	if obj.ShieldCallStep != nil {
		return obj.ShieldCallStep
	}

	if obj.ToolExecutionStep != nil {
		return obj.ToolExecutionStep
	}

	// all schemas are nil
	return nil
}

// Get the actual instance value
func (obj TurnStepsInner) GetActualInstanceValue() (interface{}) {
	if obj.InferenceStep != nil {
		return *obj.InferenceStep
	}

	if obj.MemoryRetrievalStep != nil {
		return *obj.MemoryRetrievalStep
	}

	if obj.ShieldCallStep != nil {
		return *obj.ShieldCallStep
	}

	if obj.ToolExecutionStep != nil {
		return *obj.ToolExecutionStep
	}

	// all schemas are nil
	return nil
}

type NullableTurnStepsInner struct {
	value *TurnStepsInner
	isSet bool
}

func (v NullableTurnStepsInner) Get() *TurnStepsInner {
	return v.value
}

func (v *NullableTurnStepsInner) Set(val *TurnStepsInner) {
	v.value = val
	v.isSet = true
}

func (v NullableTurnStepsInner) IsSet() bool {
	return v.isSet
}

func (v *NullableTurnStepsInner) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTurnStepsInner(val *TurnStepsInner) *NullableTurnStepsInner {
	return &NullableTurnStepsInner{value: val, isSet: true}
}

func (v NullableTurnStepsInner) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTurnStepsInner) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


